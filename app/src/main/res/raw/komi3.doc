#include <iostream>
#include <ctime>
using namespace std;
//формируем матрицу стоимости
//по алгоритму комивояжера на диагонали должны быть нули
//формируем в диапозоне от 0 до 9
void Form_matr_cost(int** a, int n) {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (i == j) {
				a[i][j] = 0;
			}
			else
				a[i][j] = rand() % 9 + 1;
		}
	}
}
//функция для вывода матрицы стоимости
//параллельно выводятся номера вершин
//что бы было наглядное представление матрицы

void Print_matr_cost(int** a, int n) {
	cout << "  ";
	for (int j = 0; j < n; j++) {
		cout << j << " ";
	}
	cout << endl;
	for (int i = 0; i < n; i++)
	{
		cout << i << "|";
		for (int j = 0; j < n; j++)
		{
			cout << a[i][j] << " ";
		}
		cout << endl;
	}
}
//нахождение столбца отличен от нуля, нужен для того , что бы минимальный элемент не был нулем
int Min_element_stroki(int** a, int n, int i_min)
{
	int j_min = 0;//начальный минимальный столбец
	int min;
	for (int j = 0; j < n; j++)
	{
		if (a[i_min][j] != 0)
		{
			j_min = j;
			break;//как только найдем первый сразу выходим из цикла

		}
	}
	return j_min;//возвращаем номер столбца минимальный
}
//алгоритм нахождение минимального пути (КОМИВОЯЖЕР)
int salesman(int** a, int n, int k, int* way)//a -на вход идет матрица стоимости, n -количество городов, номер города скоторого начинаем путь, [
											// way - храним номера городов через которые мы пройдем, при нахождение минимального пути
{
	int cost = 0;//начальная стоимоть пути
	int min;//храним минимальную стоимоть из одног огорода в другой
	int j_min;//номер в который городы мы пойдем
	int count = 0;//счетчик чтобы не уйти за границы
	int i_min = k;//номер города с которого будем начинать
	int i = k;//номер начального города
	int j;
	while (count < n)
	{
		j_min = Min_element_stroki(a, n, i);// начальная минимальная стоимоть i-того города
		min = a[i][j_min];//минимальная стоимость i- того города
		for (j = 0; j < n; j++)
		{
			if (a[i][j] != 0 && a[i][j] <= min)//поиск минимального элемента по столбцам, отличного от нуля
			{
				min = a[i][j];//минимальная стоимость из города i в город j
				j_min = j;//храним номер города, минимальной стоимости
			}

		}
		way[count] = i;//в массиве храним номер города через который пройдем
		if (count < n - 2)//проверяем, что б не удалить последний минимальный город, если мы его удалим, то можем потерять стоимоть этого города
		{
			//обнуляем конкретный элемент, поочереди двигаесь по городам
			for (int j = 0; j <= count; j++) 
			{
				a[j_min][way[j]] = 0;
			}
			//обнуляем строки и столбыцы
			for (int j = 0; j < n; j++) {
				a[i_min][j] = 0;
				a[j][j_min] = 0;
			}
		}
		else
		{
			//обнуляем строки и столбыцы
			for (int j = 0; j < n; j++)
			{
				a[i_min][j] = 0;
				a[j][j_min] = 0;
			}
		}
		cost += min;//записывает мин элемент в массив
		cout << "Выполняем алгоритм комивояжера и удаляем не нужные нам элементы" << endl;
		cout << "Минимальная стоимость из города " << i << " в " << j_min << " равна  min = " << min << endl;
		Print_matr_cost(a, n);// вывод матрицы стоимоти, нужно для простомра изменения
		cout << endl;
		i = j_min;// номер следующего города, который будем рассматривать

		count++;//увеличиваем счётчик
	}
	return cost;
}
int main() {
	setlocale(LC_ALL, "RUS");
	int** a;
	int* way;
	int cost;
	int n;//количество городов
	int k;//номер города с которого начинаем идти
	cout << "Введите всего количество городов N = ";
	cin >> n;
	cout << endl;
	//так как мы массив начинаем с нуля, то максимальный город, который мы можем ввести это n-1
	cout << "Введите первый город от в диапозоне от [0... " << n - 1 << "]" << endl;
	cin >> k;
	//выделяем память под матрицу стоимости
	a = new int* [n];
	//выделяем память под хранение номера города, для вывода пути
	way = new int[n];
	for (int i = 0; i < n; i++) {
		a[i] = new int[n];
	}
	srand(time(NULL));
	//создание матрицы стоимоти
	Form_matr_cost(a, n);
	//вывод матрицы стоимости
	cout << "Матрица стоимости: " << endl;
	Print_matr_cost(a, n);
	cout << endl;
	//алгоритм комивояжера, возвращает минимальную стоимость
	cost = salesman(a, n, k, way);// 3 метод эвристики
	cout << endl;
	//выводим путь
	cout << "Минимальная стоимоть имеет данный путь вида:" << endl;
	for (int i = 0; i < n - 1; i++) {
		cout << "(" << way[i] << "," << way[i + 1] << ")->";// вывод пути
	}
	cout << "(" << way[n - 1] << "," << way[0] << ") ";
	cout << endl;
	cout << "Минимальная стоимоть данного пути равна min = " << cost << endl;
	//удаляем память матрицы стоимоти
	for (int i = 0; i < n; i++) {
		delete[]a[i];
	}
	delete[]a;
	//удаляем память хранения номеров города
	delete[] way;
	return 0;
}